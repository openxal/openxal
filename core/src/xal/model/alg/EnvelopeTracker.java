/*
 * EnvelopeTracker.java
 *
 *  Created on September 9, 2002, 11:14 AM
 *  Modified:
 *      12/02   - CKA
 *      9/03    - CKA: added space charge interval prediction
 *                   : added rotation into ellipsoid coordinates
 *      10/06   - CKA: updated for new architecture of BeamEllipsoid
 *
 */
 
package xal.model.alg;

import xal.model.IElement;
import xal.model.IProbe;
import xal.model.ModelException;
import xal.model.elem.ChargeExchangeFoil;
import xal.model.elem.IdealMagQuad;
import xal.model.elem.IdealRfGap;
import xal.model.elem.IdealRfGapUpgraded;
import xal.model.probe.EnvelopeProbe;
import xal.model.probe.traj.EnvelopeProbeState;
import xal.model.probe.traj.ProbeState;
import xal.tools.beam.CovarianceMatrix;
import xal.tools.beam.PhaseMap;
import xal.tools.beam.PhaseMatrix;


/**
 * <p>
 * Tracking algorithm for propagating <code>EnvelopeProbe</code> objects.  
 * </p>
 * 
 * <p>
 * The <code>EnvelopeProbe</code>'s state, which is a <code>CovarianceMatrix</code> 
 * object, is propagated using the linear optics portion for any beamline 
 * element (<code>IElement</code> exposing object) transfer map.  The linear 
 * portion is represented as a matrix, thus, the state evolution is accomplished
 * by transpose conjugation with this matrix.
 * </p>
 * <p>
 * The effects of space charge are also included in the dynamics calculations.  Space charge
 * effects are also represented with a matrix transpose conjugation, however, the matrix is
 * computed using the values of the probe's correlation matrix.  The result is a nonlinear
 * effect.  The space charge forces are computed using a linear fit to the fields generated by
 * an ellipsoidal charge distribution with the same statistics described in the probe's 
 * correlation matrix.  The linear fit is weighted by the beam distribution itself, so it is 
 * more accurate in regions of higher charged density.  For a complete description see the reference
 * below.
 * </p>
 * <p>
 * A defining feature of this algorithm object is that it uses a static step size
 * when computing space charge kicks.  Thus, the step size is bound from above
 * by the lowest energy and greatest envelope excursion cases.  The step size
 * cannot be increased (say by an adaptive step sizing algorithm) to exploit
 * reduced space charge effects after acceleration.
 * </p>
 * <p>
 * NOTES: CKA
 * <br>
 * &middot; The default step size for space charge calculations is currently
 * 4 mm.  This may be overly conservative for most applications.  Not only is this
 * situation CPU intensive, but it creates a serious burden on memory resources
 * with the amount of storage required by the probe trajectory object.
 * </p> 
 *
 * @see #getStepSize()
 * @see #setStepSize(double)
 * 
 * @see xal.tools.beam.em.BeamEllipsoid
 * @see xal.model.alg.Tracker 
 * @see <a href="http://lib-www.lanl.gov/cgi-bin/getfile?00796950.pdf">Theory and Technique
 *      of Beam Envelope Simulation</a>
 *
 * @author Christopher K. Allen
 * @author Craig McChesney
 */
public class EnvelopeTracker extends EnvelopeTrackerBase {

    
    /*
     * Global Constants
     */
    

    // Versioning and definition
    /** string type identifier for algorithm */
    public static final String      s_strTypeId = EnvelopeTracker.class.getName();
    
    /** current algorithm version */
    public static final int         s_intVersion = 4;
    
    /** probe type recognized by this algorithm */
    public static final Class<EnvelopeProbe>       s_clsProbeType = EnvelopeProbe.class;
    
    
    
    /*
     *  Local Attributes
     */
     
    /** 
     *  Creates a new instance of EnvelopeTracker 
     */
    public EnvelopeTracker() { 
        super(s_strTypeId, s_intVersion, s_clsProbeType);
    };
    
    /** 
     *  Creates a new, empty, instance of EnvelopeTracker.
     *  
     *  This method is a protected constructor meant only for child classes.
     *
     *  @param      strType         string type identifier of algorithm
     *  @param      intVersion      version of algorithm
     *  @param      clsProbeType    class object for probe handled by this algorithm.
     */
    protected EnvelopeTracker(String strType, int intVersion, Class<? extends IProbe> clsProbeType) {
        super(strType, intVersion, clsProbeType);
    }
   
    /**
     * Copy constructor for EnvelopeTracker
     * 
     * @param       sourceTracker   Tracker that is being copied
     */
    protected EnvelopeTracker(EnvelopeTracker sourceTracker) {
        super(sourceTracker);
    }
    

    /**
     * Creates a deep copy of EnvelopeTracker
     */
    @Override
    public EnvelopeTracker copy() {
        return new EnvelopeTracker(this);
    }
    
    
    /**
     * Propagates the probe through the element.
     *
     *  @param  probe   probe to propagate
     *  @param  elem    element acting on probe
     *
     *  @exception  ModelException  invalid probe type or error in advancing probe
     */
    @Override
    public void doPropagation(IProbe probe, IElement elem) throws ModelException {
         
        int     cntSteps;   // number of steps through element
        double  dblStep;    // step size through element
        
        //sako
        double elemPos = this.getElemPosition();
        double elemLen = elem.getLength();
        double propLen = elemLen - elemPos;
        
        if (propLen < 0) {
        	System.err.println("doPropagation, elemPos, elemLen = "+elemPos+" "+elemLen);
        	return;
        }
  
        if(this.getUseSpacecharge())
            cntSteps = (int) Math.max(Math.ceil(propLen / getStepSize()), 1);
        else 
            cntSteps = 1;
        
        dblStep = propLen / cntSteps;
        
        /*
        if(this.getSpaceChargeFlag())
            cntSteps = (int) Math.max(Math.ceil(elem.getLength() / getStepSize()), 1);
        else 
            cntSteps = 1;
        
        dblStep = elem.getLength() / cntSteps;
*/
        for (int i=0 ; i<cntSteps ; i++) {
            this.advanceState(probe, elem, dblStep);
            this.advanceProbe(probe, elem, dblStep);
        }
    }
    


    
    /*
     * IContextAware Interface
     */
    
    /** 
     *  Advances the probe state through a subsection of the element with the
     *  specified length.  Applies a space charge kick at the end of the element
     *  subsection for any probe having nonzero beam current.
     *
     *  @param  iElem     interface to the beam element
     *  @param  ifcProbe    interface to the probe
     *  @param  dblLen      length of element subsection to advance
     *
     *  @exception ModelException     bad element transfer matrix/corrupt probe state
     */
    protected void advanceState(IProbe ifcProbe, IElement iElem, double dblLen) 
        throws ModelException 
    {
        
        // Identify probe
        EnvelopeProbe   probe = (EnvelopeProbe)ifcProbe;
        
        // Get initial conditions of probe
//        R3                 vecPhs0  = probe.getBetatronPhase();
//        Twiss[]            twiss0   = probe.getCovariance().computeTwiss();
        PhaseMatrix        matRnsp0 = probe.getResponseMatrixNoSpaceCharge();
        PhaseMatrix        matResp0 = probe.getResponseMatrix();
        CovarianceMatrix   matTau0  = probe.getCovariance();
        
        // Compute the transfer matrix
        PhaseMatrix matPhi_op = iElem.transferMap(probe, dblLen).getFirstOrder(); 
        PhaseMatrix matPhi_sc = compTransferMatrix(dblLen, probe, iElem);
        
        
        // Advance the probe states 
        PhaseMatrix matRnsp1 = matPhi_op.times( matRnsp0 );
        PhaseMatrix matResp1 = matPhi_sc.times( matResp0 );
        PhaseMatrix matTau1  = matTau0.conjugateTrans( matPhi_sc );
        
        
        if (this.getEmittanceGrowth())   
            matTau1 = this.addEmittanceGrowth(probe, iElem, matTau1);
        
        
        
        // Save the new state variables in the probe
        probe.setResponseMatrixNoSpaceCharge(matRnsp1);
        probe.setResponseMatrix(matResp1);
        probe.setCurrentResponseMatrix(matPhi_sc);
        probe.setCovariance(new CovarianceMatrix(matTau1));
//        probe.advanceTwiss(matPhi_sc, iElem.energyGain(probe, dblLen) );
        
        // phase update:
        //obsolete Twiss []    twiss1  = probe.getTwiss();
//        Twiss []    twiss1  = probe.getCovariance().computeTwiss();
//        R3          vecPhs1 = vecPhs0.plus( matPhi_sc.compPhaseAdvance(twiss0, twiss1) );
//        probe.setBetatronPhase(vecPhs1);
        
        /** sako 
         * treatment of ChargeExchangeFoil
         **/
        treatChargeExchange(probe, iElem);
    };


	/**
     * <p>Computes the transfer matrix over the incremental distance <code>dblLen</code> 
     * for the beamline modeling element <code>ifcElem</code> for the given 
     * <code>probe</code>.  We include space charge and emittance growth effects 
     * if specified.
     * </p>
     * 
     * NOTE:
     * <p>If space charge is included, the space charge matrix is computed for length
     * <code>dblLen</code>, but at a half-step position ahead of the current probe
     * position.  This method is the same technique Trace3D uses.  The space charge
     * matrix is then pre- and post multiplied by the element transfer matrix for
     * a half-step before and after the mid-step position, respectively.  I do not
     * know if this (leap-frog) technique buys us much more accuracy then full 
     * stepping.
     * </p> 
     *  
     * @param dblLen    incremental path length
     * @param probe     beam probe under simulation
     * @param ifcElem   beamline element propagating probe
     * 
     * @return      transfer matrix for given element
     * 
     * @throws ModelException   bubbles up from IElement#transferMap()
     * 
     * @see EnvelopeTracker#compScheffMatrix(double, EnvelopeProbe, PhaseMatrix)
     * @see EnvelopeTracker#modTransferMatrixForEmitGrowth(double, PhaseMatrix)
     * @see EnvelopeTracker#modTransferMatrixForDisplError(double, double, double, PhaseMatrix)
     */
    private PhaseMatrix compTransferMatrix(double dblLen, EnvelopeProbe probe, IElement ifcElem)
        throws ModelException
    {
        
        // Returned value
        PhaseMatrix matPhi;     // transfer matrix including all effects

        
        // Check for easy case of no space charge
        if (this.getUseSpacecharge()==false || dblLen==0.0)    {
            matPhi = ifcElem.transferMap(probe, dblLen).getFirstOrder();

        // we must treat space charge
        }   else {


            // Store the current probe state (for rollback)
            EnvelopeProbeState state0 = probe.cloneCurrentProbeState();
        	//ProbeState  state0 = probe.createProbeState();


            // Get half-step transfer matrix at current probe location
            PhaseMap          mapElem0 = ifcElem.transferMap(probe, dblLen/2.0); 
            PhaseMatrix       matPhi0  = mapElem0.getFirstOrder();  
            
            // Get the RMS envelopes at probe location
            CovarianceMatrix covTau0  = probe.getCovariance();    // covariance matrix at entrance
            
            
            // Advance probe a half step for position depend transfer maps
            double            pos     = probe.getPosition() + dblLen/2.0;
            PhaseMatrix       matTau1 = covTau0.conjugateTrans(matPhi0);
            CovarianceMatrix covTau1 = new CovarianceMatrix(matTau1);

            probe.setPosition(pos);
            probe.setCovariance(covTau1);
            
            
            // space charge transfer matrix
            PhaseMatrix matPhiSc = this.compScheffMatrix(dblLen, probe, ifcElem);   
            
            
            // Compute half-step transfer matrix at new probe location
            PhaseMap    mapElem1 = ifcElem.transferMap(probe, dblLen/2.0);
            PhaseMatrix matPhi1  = mapElem1.getFirstOrder();
            
            
            // Restore original probe state
            probe.applyState(state0);
            
            
            // Compute the full transfer matrix for the distance dblLen
            matPhi   = matPhi1.times( matPhiSc.times(matPhi0) );
         
        }
        
        
        // Check for exceptional circumstance and modify transfer matrix accordingly
        if (this.getEmittanceGrowth() && ifcElem instanceof IdealRfGap) {  // use this part for IdealRfGaps
            IdealRfGap elemRfGap = (IdealRfGap)ifcElem;
//        if (this.getEmittanceGrowth() && ifcElem instanceof IdealRfGapUpgraded) {
//            IdealRfGap elemRfGap = (IdealRfGap)ifcElem;
            double      dphi     = this.effPhaseSpread(probe, elemRfGap);
            
            matPhi = this.modTransferMatrixForEmitGrowth(dphi, matPhi);
        }
        
        if (ifcElem instanceof IdealMagQuad) {   // sako  put alignment error in sigma matrix
            IdealMagQuad    elemQuad = (IdealMagQuad)ifcElem;
            
            double delx = elemQuad.getAlignX();
            double dely = elemQuad.getAlignY();
            double delz = elemQuad.getAlignZ();
            
            matPhi = this.modTransferMatrixForDisplError(delx, dely, delz, matPhi);
        }
        
        return matPhi;
    }
    
    /**
     * <h2>Emittance Growth Through an RF Gap</h2>
     * <p>
     * Method to modify the covariance matrix when simulating emittance
     * growth through RF accelerating gaps.  (The method only 
     * considers the  case of propagation 
     * through an <code>IdealRfGap</code> element).  If the <code>IElement</code>
     * argument is any other type of element, nothing is done.
     * The argument <code>matTau</code> is the covariance matrix after the
     * usual propagation through the <code>elem</code> element.
     * </p> 
     * <p>
     * Let <i>x</i> be either transverse phase space variable.  The emittance growth 
     * effect is achieved
     * by first multiplying the element &lt;x'|x&gt; of the RF gap transfer
     * matrix <b>&Phi;</b> by the factor 
     * <i>F<sub>t</sub></i>(&Delta;<i>&phi;</i>)
     * returned by method 
     * {@link EnvelopeTrackerBase#compTransFourierTransform(double)} 
     * (see {@link EnvelopeTrackerBase#modTransferMatrixForEmitGrowth(double, PhaseMatrix)}).
     * Currently this action is done in 
     * {@link #compTransferMatrix(double, EnvelopeProbe, IElement)}.
     * Once the  covariance matrix <b>&tau;</b> is propagated by the modified transfer 
     * matrix <b>&Phi;</b>, the moment &lt;<i>x'</i><sup>2</sup>&gt; is 
     * augmented by the result of this function.
     * </p>
     * <p>
     * Specifically, the action of this method is described as follows:
     * The before gap and after gap transverse RMS divergence angles, 
     * <i>x'<sub>i</sub></i> and 
     * <i>x'<sub>f</sub></i>, respectively, 
     * are related by the following formula:
     * <br>
     * <br>
     * &nbsp; &lt;<i>x'<sub>f</sub></i><sup>2</sup>&gt; = 
     *         &Delta;&lt;<i>x'<sub>f</sub></i><sup>2</sup>&gt; +
     *         &lt;<i>x'<sub>i</sub></i><sup>2</sup>&gt;
     * <br>
     * <br>
     * where &Delta;&lt;<i>x'<sub>f</sub></i><sup>2</sup>&gt;
     * is the emittance growth factor given by
     * <br>
     * <br>
     * &nbsp;  &Delta;&lt;<i>x'<sub>f</sub></i><sup>2</sup>&gt; &equiv; 
     *        <i>k<sub>t</sub></i><sup>2</sup>
     *        <i>G<sub>t</sub></i>(<i>&phi;<sub>s</sub></i>,&Delta;<i>&phi;</i>)
     *        &lt;<i>x<sub>i</sub></i></i><sup>2</sup>&gt;.
     * <br>
     * <br>
     * where 
     * <i>G<sub>t</sub></i>(<i>&phi;<sub>s</sub></i>,&Delta;<i>&phi;</i>)
     * is the transverse 3-dimensional emittance growth function,
     * and <i>x<sub>i</sub></i> represents the 
     * before-gap position for <em>either</em>
     * transverse phase plane.  The action of this method is described
     * by the original equation.
     * </p>
     * <p>
     * The resulting action on the before gap and after gap transverse RMS emittances, 
     * <i>&epsilon;<sub>t,i</sub></i> and 
     * <i>&epsilon;<sub>t,f</sub></i>, respectively, 
     * is now described by the following formula:
     * <br>
     * <br>
     * &nbsp; <i>&epsilon;<sub>t,f</sub></i><sup>2</sup> = 
     *        <i>&eta;</i><sup>2</sup><i>&epsilon;<sub>t,i</sub></i><sup>2</sup> +
     *        &Delta;<i>&epsilon;<sub>t,f</sub></i><sup>2</sup>
     * <br>
     * <br>
     * where <i>&eta;</i> is the momentum compaction due to acceleration
     * <br>
     * <br>
     *  <i>&eta;</i> &equiv; 
     *    <i>&beta;<sub>i</sub>&gamma;<sub>i</sub></i>/<i>&beta;<sub>f</sub>&gamma;<sub>f</sub></i>
     * <br>
     * <br>
     * and &Delta;<i>&epsilon;<sub>t,f</sub></i> is the emittance increase term 
     * <br>
     * <br>
     * &nbsp;  &Delta;<i>&epsilon;<sub>t,f</sub></i><sup>2</sup> &equiv; 
     *        &Delta;&lt;<i>x'<sub>f</sub></i><sup>2</sup>&gt;
     *        &lt;<i>x<sub>f</sub></i></i><sup>2</sup>&gt;<sup>2</sup>.
     * <br>
     * <br>
     * There are analogous formulas for the before and after gap
     * longitudinal plane emittances 
     * <i>&epsilon;<sub>z,i</sub></i> and 
     * <i>&epsilon;<sub>z,f</sub></i>, respectively, with
     * <i>G<sub>t</sub></i>(<i>&phi;<sub>s</sub></i>,&Delta;<i>&phi;</i>)
     * replaced by 
     * <i>G<sub>z</sub></i>(<i>&phi;<sub>s</sub></i>,&Delta;<i>&phi;</i>) 
     * and <i>x</i><sub>(<i>f,i</i>)</sub> replaced by 
     * <i>z</i><sub>(<i>f,i</i>)</sub>.  
     * </p> 
     * <p>
     * <strong>NOTES</strong>: CKA
     * <br>
     * &middot; Since we are modeling the RF gap as a thin lens, only the 
     * momentum (divergance angle) is modified, &lt;<i>x</i><sup>2</sup>&gt;,
     * &lt;<i>y</i><sup>2</sup>&gt;, and &lt;<i>z</i><sup>2</sup>&gt; remain
     * unaffected.  Thus, &lt;<i>x<sub>f</sub></i><sup>2</sup>&gt;
     * = &lt;<i>x<sub>i</sub></i><sup>2</sup>&gt; and
     * &lt;<i>z<sub>f</sub></i><sup>2</sup>&gt;
     * = &lt;<i>z<sub>i</sub></i><sup>2</sup>&gt; and may be computed
     * as such in the above.
     * <br>
     * &middot; The &lt;<i>x'</i><sup>2</sup>&gt; element is modified by the formula
     * <br>
     * <br>
     * &nbsp; &lt;<i>x'</i><sup>2</sup>&gt; = &lt;<i>x'</i><sup>2</sup>&gt; + <i>c<sub>eg</sub></i>&lt;<i>x</i><sup>2</sup>&gt;
     * <br>
     * <br>
     * where <i>c<sub>eg</sub></i> is the emittance growth coefficent.  There are similar 
     * equations for the other phase planes.  The emittance growth coefficents are computed
     * in the base class <code>EnvelopeTrackerBase</code> by the methods 
     * <code>emitGrowthCoefTrans(EnvelopeProbe, IdealRfGap)</code> and 
     * <code>emitGrowthCoefLong(EnvelopeProbe, IdealRfGap)</code>.
     * </p>  
     * <p>
     * <strong>NOTES</strong>: (H. SAKO)
     * <br>
     *  &middot; Increase emittance using same (nonlinear) procedure on the second
     *  moments as in Trace3D. 
     * </p>
     * 
     * @param   iElem        <code>IElement</code> element for exceptional processing
     * @param   probe       <code>IProbe</code> object associated with correlation matrix
     * @param   matTau      correlation matrix after (normal) propagation thru <code>elem</code>
     * 
     * @return  covariance matrix of <code>probe</code> after adjusting for emittance growth
     * 
     * @throws  ModelException  unknown/unsupported emittance growth model, or
     *                          unknown/unsupported phase plane
     * 
     * @see #compTransferMatrix(double, EnvelopeProbe, IElement)
     * @see EnvelopeTrackerBase#compTransFourierTransform(double)
     * @see EnvelopeTrackerBase#compLongFourierTransform(double)
     * 
     * @author  Hiroyuki Sako
     * @author  Christopher K. Allen
     */
    private PhaseMatrix   addEmittanceGrowth(EnvelopeProbe probe, IElement iElem, PhaseMatrix matTau) 
        throws ModelException
    {
        
        // Check for RF Gap
        if (!(iElem instanceof IdealRfGap))
            return matTau;
        
        if (!this.getEmittanceGrowth())
            return matTau;
  
        
        // Get the synchronous phase and compute the phase spread 
        IdealRfGap  elemRfGap = (IdealRfGap)iElem;
        
        double  phi_s = elemRfGap.getPhase();
        double  dphi  = this.effPhaseSpread(probe, elemRfGap);


        // Compute the divergence angle increment coefficients 
        //  (emittance growth coefficients)
        double  dxp_2;      // transverse divergence angle augmentation factor
        double  dzp_2;      // longitudinal divergence angle augmentation factor

        //        if (this.getEmitGrowthModel() == EmitGrowthModel.TRACE3D) {
        //            
        //            dxp_2 = this.emitGrowthCoefTrans(probe, elemRfGap);
        //            dzp_2 = this.emitGrowthCoefLong(probe, elemRfGap);
        //
        //        } else {

        double  Gt    = this.compEmitGrowthFunction(PhasePlane.TRANSVERSE, phi_s, dphi);
        double  kt    = elemRfGap.compTransFocusing(probe);
        dxp_2 = kt*kt*Gt;

        double  Gz    = this.compEmitGrowthFunction(PhasePlane.LONGITUDINAL, phi_s, dphi);
        double  kz    = elemRfGap.compLongFocusing(probe);
        //    double  gf    = elemRfGap.gammaFinal(probe);
        //    double  gf_2  = gf*gf;
        //            dzp_2 = kz*kz*Gz/(gf_2*gf_2);
        dzp_2 = kz*kz*Gz;

        //        }


        // Compute new correlation matrix
        //      Transverse planes
        double x_2    = matTau.getElem(0,0);
        double xp_2   = matTau.getElem(1,1);
        double xp_2eg = dxp_2*x_2 + xp_2; 
        matTau.setElem(1,1,xp_2eg);

        double y_2    = matTau.getElem(2,2);
        double yp_2   = matTau.getElem(3,3);
        double yp_2eg = dxp_2*y_2 + yp_2; 
        matTau.setElem(3,3,yp_2eg);

        //      Longitudinal plane
        double z_2    = matTau.getElem(4,4);
        double zp_2   = matTau.getElem(5,5);
        double zp_2eg = dzp_2*z_2 + zp_2; 
        matTau.setElem(5,5,zp_2eg);

        return matTau;
    }

    /**
     * Test for a <code>ChargeExchangeFoil</code> element.
     * If found, the probe represent an H<sup>-</sup> beam, the electrons 
     * are stripped and the beam becomes H<sup>+</sup>.
     * 
     * @param probe    Propagating beam
     * @param ifcElem  Element to tested for <code>ChargeExchangeFoil</code> type
     * 
     * @author Hiroyuki Sako
     * 
     * @see xal.model.elem.ChargeExchangeFoil
     */
    private void treatChargeExchange(EnvelopeProbe probe, IElement ifcElem) {
    	if (ifcElem instanceof ChargeExchangeFoil) {
    		double q = probe.getSpeciesCharge();
    		if (q<0) {
    			System.out.println("charge exchanged at "+ifcElem.getId()+" from "+q+" to "+ (-q));
    			probe.setSpeciesCharge(-q);
    		}
    	}
    }
    
}



/*
 *  Storage
 */
 
 
